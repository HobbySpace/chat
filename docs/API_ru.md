<!-- TOC depthfrom:1 depthto:6 withlinks:true updateonsave:true orderedlist:false -->

- [API сервера](#api-сервера)
    - [Как это работает?](#как-это-работает)
    - [Общие соображения](#общие-соображения)
    - [Подключение к серверу](#подключение-к-серверу)
        - [gRPC](#grpc)
        - [WebSocket](#websocket)
        - [Long Polling](#long-polling)
        - [Большие файлы вне полосы](#большие-файлы-вне-полосы)
        - [Работа за обратным прокси](#работа-за-обратным-прокси)
    - [Пользователи](#пользователи)
        - [Аутентификация](#аутентификация)
            - [Создание аккаунта](#создание-аккаунта)
            - [Вход в систему](#вход-в-систему)
            - [Изменение параметров аутентификации](#изменение-параметров-аутентификации)
            - [Сброс пароля, т.е. "Забыл пароль"](#сброс-пароля-т.е.-забыл-пароль)
        - [Блокировка пользователя](#блокировка-пользователя)
        - [Проверка учетных данных](#проверка-учетных-данных)
        - [Контроль доступа](#контроль-доступа)
    - [Топики](#топики)
        - [Топик me](#топик-me)
        - [fnd и теги: Поиск пользователей и топиков](#fnd-и-теги-поиск-пользователей-и-топиков)
            - [Язык запросов](#язык-запросов)
            - [Инкрементальные обновления запросов](#инкрементальные-обновления-запросов)
            - [Переписывание запросов](#переписывание-запросов)
            - [Возможные случаи использования](#возможные-случаи-использования)
        - [Peer to Peer топики](#peer-to-peer-топики)
        - [Групповые топики](#групповые-топики)
        - [Топик sys](#топик-sys)
    - [Использование ID сообщений, выданных сервером](#использование-id-сообщений-выданных-сервером)
    - [User Agent и уведомления о присутствии](#user-agent-и-уведомления-о-присутствии)
    - [Поля Trusted, Public, Private, Auxiliary](#поля-trusted-public-private-auxiliary)
        - [Trusted](#trusted)
        - [Public](#public)
        - [Private](#private)
        - [Auxiliary](#auxiliary)
    - [Формат содержимого](#формат-содержимого)
    - [Обработка больших файлов вне полосы](#обработка-больших-файлов-вне-полосы)
        - [Загрузка](#загрузка)
        - [Скачивание](#скачивание)
    - [Push-уведомления](#push-уведомления)
        - [Tinode Push Gateway](#tinode-push-gateway)
        - [Google FCM](#google-fcm)
        - [Stdout](#stdout)
    - [Видеозвонки](#видеозвонки)
    - [Превью ссылок](#превью-ссылок)
    - [Сообщения](#сообщения)
        - [Сообщения от клиента к серверу](#сообщения-от-клиента-к-серверу)
            - [{hi}](#hi)
            - [{acc}](#acc)
            - [{login}](#login)
            - [{sub}](#sub)
            - [{leave}](#leave)
            - [{pub}](#pub)
            - [{get}](#get)
            - [{set}](#set)
            - [{del}](#del)
            - [{note}](#note)
        - [Сообщения от сервера к клиенту](#сообщения-от-сервера-к-клиенту)
            - [{data}](#data)
            - [{ctrl}](#ctrl)
            - [{meta}](#meta)
            - [{pres}](#pres)
            - [{info}](#info)

<!-- /TOC -->

# API сервера

## Как это работает?

Tinode — это маршрутизатор и хранилище для обмена сообщениями. Концептуально он следует модели [публикации-подписки](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern).

Сервер связывает сессии, пользователей и топики. Сессия — это сетевое соединение между клиентским приложением и сервером. Пользователь представляет человека, который подключается к серверу через сессию. Топик — это именованный канал связи, который маршрутизирует содержимое между сессиями.

Пользователям и топикам присваиваются уникальные ID. ID пользователя — это строка с префиксом 'usr', за которым следует base64-URL-кодированное псевдослучайное 64-битное число, например `usr2il9suCbuko`. ID топиков описаны ниже.

Клиенты, такие как мобильные или веб-приложения, создают сессии, подключаясь к серверу через websocket или long polling. Для выполнения большинства операций требуется аутентификация клиента. Клиент аутентифицирует сессию, отправляя пакет `{login}`. Подробности см. в разделе [Аутентификация](#аутентификация). После аутентификации клиент получает токен, который используется для последующей аутентификации. Один и тот же пользователь может установить несколько одновременных сессий. Выход из системы не поддерживается (и не требуется).

После установления сессии пользователь может начать взаимодействовать с другими пользователями через топики. Доступны следующие типы топиков:

* `me` — топик для управления профилем и получения уведомлений о других топиках; топик `me` существует для каждого пользователя.
* `fnd` — топик для поиска других пользователей и топиков; топик `fnd` также существует для каждого пользователя.
* Peer to peer топик — канал связи строго между двумя пользователями. Каждый участник видит имя топика как ID другого участника: префикс 'usr', за которым следует base64-URL-кодированная числовая часть ID пользователя, например `usr2il9suCbuko`.
* Групповой топик — канал для многосторонней связи. Называется 'grp', за которым следует 11 псевдослучайных символов, т.е. `grpYiqEXb4QY6s`. Групповые топики должны быть явно созданы.

Сессия присоединяется к топику, отправляя пакет `{sub}`. Пакет `{sub}` выполняет три функции: создание нового топика, подписка пользователя на топик и присоединение сессии к топику. Подробности см. в разделе [`{sub}`](#sub) ниже.

После того как сессия присоединилась к топику, пользователь может начать генерировать содержимое, отправляя пакеты `{pub}`. Содержимое доставляется другим присоединенным сессиям в виде пакетов `{data}`.

Пользователь может запрашивать или обновлять метаданные топика, отправляя пакеты `{get}` и `{set}`.

Изменения в метаданных топика, такие как изменения в описании топика или когда другие пользователи присоединяются или покидают топик, сообщаются активным сессиям пакетом `{pres}` (presence). Пакет `{pres}` отправляется либо в затронутый топик, либо в топик `me`.

Когда топик `me` пользователя становится онлайн (т.е. аутентифицированная сессия присоединяется к топику `me`), пакет `{pres}` отправляется в топики `me` всех других пользователей, у которых есть peer to peer подписки с первым пользователем.

## Общие соображения

Временные метки всегда представлены в виде строки в формате [RFC 3339](http://tools.ietf.org/html/rfc3339) с точностью до миллисекунд и часовым поясом, всегда установленным в UTC, например `"2015-10-06T18:07:29.841Z"`.

Везде, где упоминается кодирование base64, имеется в виду base64 URL-кодирование с удаленными символами заполнения, см. [RFC 4648](http://tools.ietf.org/html/rfc4648).

Пакеты `{data}` имеют последовательные ID, выданные сервером: числа по основанию 10, начиная с 1 и увеличиваясь на единицу с каждым сообщением. Они гарантированно уникальны для каждого топика.

Для связи запросов с ответами клиент может назначать ID сообщений всем пакетам, отправляемым на сервер. Эти ID — строки, определенные клиентом. Клиент должен делать их уникальными хотя бы для каждой сессии. ID, назначенные клиентом, не интерпретируются сервером, они возвращаются клиенту как есть.

## Подключение к серверу

Есть три способа доступа к серверу по сети: websocket, long polling и [gRPC](https://grpc.io/).

Когда клиент устанавливает соединение с сервером по HTTP(S), например через websocket или long polling, сервер предлагает следующие эндпоинты:
* `/v0/channels` для websocket соединений
* `/v0/channels/lp` для long polling
* `/v0/file/u` для загрузки файлов
* `/v0/file/s` для обслуживания файлов (скачивание)

`v0` обозначает версию API (в настоящее время ноль). Каждый HTTP(S) запрос должен включать API ключ. Сервер проверяет API ключ в следующем порядке:
* HTTP заголовок `X-Tinode-APIKey`
* URL параметр запроса `apikey` (/v0/file/s/abcdefg.jpeg?apikey=...)
* Значение формы `apikey`
* Cookie `apikey`

Ключ API по умолчанию включен в каждое демо-приложение для удобства. Сгенерируйте свой собственный ключ для продакшена, используя [утилиту `keygen`](../keygen).

После открытия соединения клиент должен отправить сообщение `{hi}` на сервер. Сервер отвечает сообщением `{ctrl}`, которое указывает либо на успех, либо на ошибку. Поле `params` ответа содержит версию протокола сервера `"params":{"ver":"0.15"}` и может включать другие значения.

### gRPC

См. определение gRPC API в [proto файле](../pbx/model.proto). gRPC API имеет немного больше функциональности, чем API, описанный в этом документе: он позволяет пользователю `root` отправлять сообщения от имени других пользователей, а также удалять пользователей.

Поля `bytes` в protobuf сообщениях ожидают JSON-кодированное содержимое UTF-8. Например, строка должна быть заключена в кавычки перед преобразованием в байты как UTF-8: `[]byte("\"some string\"")` (Go), `'"another string"'.encode('utf-8')` (Python 3).

### WebSocket

Сообщения отправляются в текстовых фреймах, по одному сообщению на фрейм. Бинарные фреймы зарезервированы для будущего использования. По умолчанию сервер разрешает соединения с любым значением в заголовке `Origin`.

### Long Polling

Long polling работает через `HTTP POST` (предпочтительно) или `GET`. В ответ на первый запрос клиента сервер отправляет сообщение `{ctrl}`, содержащее `sid` (ID сессии) в `params`. Клиент long polling должен включать `sid` в каждый последующий запрос либо в URL, либо в теле запроса.

Сервер разрешает соединения со всех источников, т.е. `Access-Control-Allow-Origin: *`

### Большие файлы вне полосы

Большие файлы отправляются вне полосы, используя `HTTP POST` с `Content-Type: multipart/form-data`. Подробности см. [ниже](#обработка-больших-файлов-вне-полосы).

### Работа за обратным прокси

Сервер Tinode может быть настроен для работы за обратным прокси, таким как NGINX. Для эффективности он может принимать клиентские соединения из Unix сокетов, установив параметры конфигурации `listen` и/или `grpc_listen` в путь к файлу Unix сокета, например `unix:/run/tinode.sock`. Сервер также может быть настроен для чтения IP-адреса пира из HTTP заголовка `X-Forwarded-For`, установив параметр конфигурации `use_x_forwarded_for` в `true`.

## Пользователи

Пользователь представляет человека, конечного пользователя: производителя и потребителя сообщений.

Пользователям обычно присваивается один из двух уровней аутентификации: аутентифицированный `auth` или анонимный `anon`. Третий уровень `root` доступен только через `gRPC`, где он разрешает `root` отправлять сообщения от имени других пользователей.

Когда соединение впервые устанавливается, клиентское приложение может отправить сообщение `{acc}` или `{login}`, которое аутентифицирует пользователя на одном из уровней.

Каждому пользователю присваивается уникальный ID. ID состоят из `usr`, за которым следует base64-кодированное 64-битное числовое значение, например `usr2il9suCbuko`. Пользователи также имеют следующие свойства:

* `created`: временная метка создания записи пользователя
* `updated`: временная метка последнего обновления `public` или `trusted` пользователя
* `status`: состояние аккаунта
* `username`: уникальная строка, используемая в аутентификации `basic`; имя пользователя недоступно другим пользователям
* `defacs`: объект, описывающий режим доступа пользователя по умолчанию для peer to peer разговоров с аутентифицированными и анонимными пользователями; подробности см. в разделе [Контроль доступа](#контроль-доступа)
    * `auth`: режим доступа по умолчанию для аутентифицированных пользователей `auth`
    * `anon`: режим доступа по умолчанию для анонимных пользователей `anon`
* `trusted`: объект, определенный приложением, выданный системной администрацией. Любой может читать его, но только системные администраторы могут изменять его.
* `public`: объект, определенный приложением, который описывает пользователя. Любой может запросить `public` данные пользователя.
* `private`: объект, определенный приложением, который уникален для текущего пользователя и доступен только пользователю.
* `tags`: [обнаружение](#fnd-и-теги-поиск-пользователей-и-топиков) и учетные данные.

Аккаунт пользователя имеет состояние. Определены следующие состояния:
* `ok` (нормальное): состояние по умолчанию, которое означает, что аккаунт не ограничен никаким образом и может использоваться нормально;
* `susp` (заблокирован): пользователю запрещен доступ к аккаунту, а также он не найден через [поиск](#fnd-и-теги-поиск-пользователей-и-топиков); это состояние может быть назначено администратором и полностью обратимо.
* `del` (мягко удален): пользователь помечен как удаленный, но данные пользователя сохранены; восстановление пользователя в настоящее время не поддерживается.
* `undef` (неопределен): используется внутренне аутентификаторами; не должно использоваться в других местах.

Пользователь может поддерживать несколько одновременных соединений (сессий) с сервером. Каждая сессия помечена строкой `User Agent`, предоставленной клиентом, предназначенной для различения клиентского программного обеспечения.

Выход из системы не поддерживается по дизайну. Если приложению нужно сменить пользователя, оно должно открыть новое соединение и аутентифицировать его с новыми учетными данными пользователя.


### Аутентификация

Аутентификация концептуально похожа на [SASL](https://en.wikipedia.org/wiki/Simple_Authentication_and_Security_Layer): она предоставляется как набор адаптеров, каждый из которых реализует другой метод аутентификации. Аутентификаторы используются во время регистрации аккаунта [`{acc}`](#acc) и во время [`{login}`](#login). Сервер поставляется со следующими методами аутентификации из коробки:

* `token` предоставляет аутентификацию криптографическим токеном.
* `basic` предоставляет аутентификацию парой логин-пароль.
* `anonymous` предназначен для случаев, когда пользователи временные, например, обработка запросов службы поддержки через чат.
* `rest` — это [мета-метод](../server/auth/rest/), который позволяет использовать внешние системы аутентификации посредством JSON RPC.

Любой другой метод аутентификации может быть реализован с использованием адаптеров.

`token` предназначен быть основным средством аутентификации. Токены разработаны таким образом, что аутентификация по токену является легковесной. Например, аутентификатор токена обычно не делает никаких запросов к базе данных, вся обработка выполняется в памяти. Все другие методы аутентификации предназначены для использования только для получения или обновления токена. После получения токена последующие входы должны использовать его.

Схема аутентификации `basic` ожидает, что `secret` будет base64-кодированной строкой строки, состоящей из имени пользователя, за которым следует двоеточие `:`, за которым следует пароль в открытом тексте. Имя пользователя в схеме `basic` не должно содержать символ двоеточия `:` (ASCII 0x3A).

Схема `anonymous` может использоваться для создания аккаунтов, она не может использоваться для входа: пользователь создает аккаунт, используя схему `anonymous`, и получает криптографический токен, который он использует для последующих входов с `token`. Если токен потерян или истек, пользователь больше не может получить доступ к аккаунту.

Имена встроенных аутентификаторов могут быть изменены с помощью функции конфигурации `logical_names`. Например, пользовательский аутентификатор `rest` может быть представлен как `basic` вместо стандартного, или аутентификатор `token` может быть скрыт от пользователей. Функция активируется путем предоставления массива сопоставлений в файле конфигурации: `logical_name:actual_name` для переименования или `actual_name:` для скрытия. Например, чтобы использовать службу `rest` для базовой аутентификации, используйте `"logical_names": ["basic:rest"]`.


#### Создание аккаунта

При создании нового аккаунта пользователь должен сообщить серверу, какой метод аутентификации будет использоваться позже для доступа к этому аккаунту, а также предоставить общий секрет, если это уместно. Только `basic` и `anonymous` могут использоваться при создании аккаунта. `basic` требует, чтобы пользователь сгенерировал и отправил уникальный логин и пароль на сервер. `anonymous` не обменивается секретами.

Пользователь может опционально установить `{acc login=true}` для использования нового аккаунта для немедленной аутентификации. Когда `login=false` (или не установлено), новый аккаунт создается, но статус аутентификации сессии, которая создала аккаунт, остается неизменным. Когда `login=true` сервер попытается аутентифицировать сессию с новым аккаунтом, ответ `{ctrl}` на запрос `{acc}` будет содержать токен аутентификации при успехе. Это особенно важно для аутентификации `anonymous`, потому что это единственный раз, когда токен аутентификации может быть получен.

#### Вход в систему

Вход в систему выполняется путем отправки запроса `{login}`. Вход возможен только с `basic` и `token`. Ответ на любой вход — это сообщение `{ctrl}` либо с кодом 200 и токеном, который может использоваться в последующих входах с аутентификацией `token`, либо с кодом 300 запросом дополнительной информации, такой как проверка учетных данных или ответ на вызов, зависящий от метода в многошаговой аутентификации, либо с кодом ошибки 4xx.

Токен имеет время истечения, настроенное на сервере, поэтому его необходимо периодически обновлять.

#### Изменение параметров аутентификации

Пользователь может изменить параметры аутентификации, такие как изменение логина и пароля, отправив запрос `{acc}`. Только аутентификация `basic` в настоящее время поддерживает изменение параметров:
```js
acc: {
  id: "1a2b3", // string, ID сообщения, предоставленный клиентом, опционально
  user: "usr2il9suCbuko", // пользователь, на которого влияет изменение, опционально
  token: "XMg...g1Gp8+BO0=", // токен аутентификации, если сессия
                             // еще не аутентифицирована, опционально.
  scheme: "basic", // схема аутентификации, которая обновляется.
  secret: base64encode("new_username:new_password") // новые параметры
}
```
Чтобы изменить только пароль, `username` должен быть оставлен пустым, т.е. `secret: base64encode(":new_password")`.

Если сессия не аутентифицирована, запрос должен включать `token`. Это может быть обычный токен аутентификации, полученный при входе, или ограниченный токен, полученный через процесс [Сброса пароля](#сброс-пароля-т.е.-забыл-пароль). Если сессия аутентифицирована, токен не должен включаться. Если запрос аутентифицирован для уровня доступа `ROOT`, то `user` может быть установлен в действительный ID другого пользователя. В противном случае он должен быть пустым (по умолчанию текущий пользователь) или равен ID текущего пользователя.


#### Сброс пароля, т.е. "Забыл пароль"

Чтобы сбросить логин или пароль (или любой другой секрет аутентификации, если такое действие поддерживается аутентификатором), отправляется сообщение `{login}` с `scheme`, установленным в `reset`, и `secret`, содержащим base64-кодированную строку "`схема аутентификации для сброса секрета`:`метод сброса`:`значение метода сброса`". Самый простой случай сброса пароля по электронной почте:
```js
login: {
  id: "1a2b3",
  scheme: "reset",
  secret: base64encode("basic:email:jdoe@example.com")
}
```
где `jdoe@example.com` — ранее проверенный email пользователя.

Если email соответствует регистрации, сервер отправит сообщение, используя указанный метод и адрес, с инструкциями по сбросу секрета. Email содержит ограниченный токен безопасности, который пользователь может включить в запрос `{acc}` с новым секретом, как описано в разделе [Изменение параметров аутентификации](#изменение-параметров-аутентификации).

### Блокировка пользователя

Аккаунт пользователя может быть заблокирован администратором службы. После блокировки аккаунта пользователь больше не может войти в систему и использовать службу.

Только пользователь `root` может заблокировать аккаунт. Чтобы заблокировать аккаунт, пользователь root отправляет следующее сообщение:
```js
acc: {
  id: "1a2b3", // string, ID сообщения, предоставленный клиентом, опционально
  user: "usr2il9suCbuko", // пользователь, на которого влияет изменение
  status: "susp"
}
```
Отправка того же сообщения с `status: "ok"` разблокирует аккаунт. Пользователь root может проверить статус аккаунта, выполнив команду `{get what="desc"}` против топика `me` пользователя.


### Проверка учетных данных

Сервер может быть опционально настроен для требования проверки определенных учетных данных, связанных с аккаунтами пользователей и схемой аутентификации. Например, можно потребовать, чтобы пользователь предоставил уникальный email или номер телефона, или решил капчу как условие регистрации аккаунта.

Сервер поддерживает проверку email из коробки с простым изменением конфигурации. Проверка телефонных номеров в основном функциональна, но не полностью функциональна, поскольку требуется коммерческая подписка для отправки текстовых сообщений (SMS).

Если требуются определенные учетные данные, пользователь должен поддерживать их в проверенном состоянии все время. Это означает, что если требуемый учетный данные должны быть изменены, пользователь должен сначала добавить и проверить новые учетные данные, и только затем удалить старые.

Учетные данные изначально назначаются во время регистрации путем отправки сообщения `{acc}`, добавляются с помощью `{set topic="me"}`, удаляются с помощью `{del topic="me"}` и запрашиваются сообщениями `{get topic="me"}`. Учетные данные проверяются клиентом путем отправки сообщения `{login}` или `{acc}`.


### Контроль доступа

Контроль доступа управляет доступом пользователя к топикам через списки контроля доступа (ACL). Доступ назначается индивидуально для каждой пары пользователь-топик (подписка).

Контроль доступа в основном применим для групповых топиков. Его применимость для топиков `me` и P2P ограничена управлением уведомлениями о присутствии и запретом пользователям инициировать или продолжать P2P разговоры. Всем читателям каналов предоставляются одинаковые разрешения.

Доступ пользователя к топику определяется двумя наборами разрешений: желаемыми разрешениями пользователя "want" и разрешениями, предоставленными пользователю менеджерами топика "given". Каждое разрешение представлено битом в битовой карте. Оно может быть либо установлено, либо отсутствовать. Фактический доступ определяется как побитовое И (AND) желаемых и предоставленных разрешений. Разрешения передаются в сообщениях как набор символов ASCII, где наличие символа означает установленный бит разрешения:

* Нет доступа: `N` — это не разрешение само по себе, а индикатор того, что разрешения явно очищены/не установлены. Обычно это указывает, что разрешения по умолчанию *не* должны применяться.
* Присоединение: `J`, разрешение на подписку на топик
* Чтение: `R`, разрешение на получение пакетов `{data}`
* Запись: `W`, разрешение на `{pub}` в топик
* Присутствие: `P`, разрешение на получение обновлений присутствия `{pres}`
* Одобрение: `A`, разрешение на одобрение запросов на присоединение к топику, удаление и блокировку участников; пользователь с таким разрешением является администратором топика
* Обмен: `S`, разрешение на приглашение других людей присоединиться к топику
* Удаление: `D`, разрешение на жесткое удаление сообщений; только владельцы могут полностью удалять топики
* Владелец: `O`, пользователь является владельцем топика; владелец может назначать любые другие разрешения любому участнику топика, изменять описание топика, удалять топик; топик может иметь только одного владельца; некоторые топики не имеют владельца

Когда пользователь подписывается на топик или начинает чат с другим пользователем, разрешения доступа либо устанавливаются явно, либо назначаются по умолчанию `defacs`. Разрешения доступа могут быть изменены путем отправки сообщений `{set}`.

Клиент может установить явные разрешения в сообщениях `{sub}` и `{set}`. Если разрешения отсутствуют или установлены в пустую строку (не `N`!), Tinode будет использовать разрешения по умолчанию `defacs`, назначенные ранее. Если разрешения по умолчанию не найдены, аутентифицированные пользователи в групповых топиках получат доступ `JRWPS`, в P2P топиках получат `JRWPA`; анонимные пользователи получат `N` (нет доступа), что означает, что каждый запрос на подписку должен быть явно одобрен менеджером топика.

Доступ по умолчанию определяется для двух категорий пользователей: аутентифицированных и анонимных. Значение доступа по умолчанию применяется как разрешение "given" ко всем новым подпискам. Доступ по умолчанию топика устанавливается во время создания топика через `{sub.desc.defacs}` и может быть впоследствии изменен владельцем путем отправки сообщений `{set}`. Аналогично, доступ по умолчанию пользователя устанавливается во время создания аккаунта через `{acc.desc.defacs}` и может быть изменен пользователем путем отправки сообщения `{set}` в топик `me`.


## Топики

Топик — это именованный канал связи для одного или нескольких человек. Топики имеют постоянные свойства. Эти свойства топика могут быть запрошены сообщением `{get what="desc"}`.

Свойства топика, не зависящие от пользователя, делающего запрос:
* `created`: временная метка времени создания топика
* `updated`: временная метка последнего обновления `trusted`, `public` или `private` топика
* `touched`: временная метка последнего сообщения, отправленного в топик
* `defacs`: объект, описывающий режим доступа по умолчанию топика для аутентифицированных и анонимных пользователей; подробности см. в разделе [Контроль доступа](#контроль-доступа)
* `auth`: режим доступа по умолчанию для аутентифицированных пользователей
* `anon`: режим доступа по умолчанию для анонимных пользователей
* `seq`: целое число, последовательный ID, выданный сервером, последнего сообщения `{data}`, отправленного через топик
* `trusted`: объект, определенный приложением, выданный системными администраторами. Любой может читать его, но только администраторы могут изменять его.
* `public`: объект, определенный приложением, который описывает топик. Любой, кто может подписаться на топик, может получить `public` данные топика, только `owner` топика может изменять их.

Свойства топика, зависящие от пользователя:
* `acs`: объект, описывающий текущие разрешения доступа данного пользователя; подробности см. в разделе [Контроль доступа](#контроль-доступа)
* `want`: разрешение доступа, запрошенное этим пользователем
* `given`: разрешения доступа, предоставленные этому пользователю
* `private`: объект, определенный приложением, который уникален для текущего пользователя (подписчика топика).

Топики обычно имеют подписчиков. Один из подписчиков может быть назначен владельцем топика (разрешение доступа `O`) с полными разрешениями доступа. Список подписчиков может быть запрошен сообщением `{get what="sub"}`. Список подписчиков возвращается в разделе `sub` сообщения `{meta}`.

### Топик `me`

Топик `me` автоматически создается для каждого пользователя во время создания аккаунта. Он служит средством управления информацией аккаунта, получения уведомлений о присутствии от людей и топиков интереса. Топик `me` не имеет владельца. Топик не может быть удален или отписан. Можно `leave` топик, что остановит всю соответствующую связь и укажет, что пользователь офлайн (хотя пользователь может все еще быть залогинен и может продолжать использовать другие топики).

Присоединение или выход из `me` генерирует обновление присутствия `{pres}`, отправляемое всем пользователям, у которых есть peer to peer топики с данным пользователем и установлены разрешения `P`.

Топик `me` доступен только для чтения. Сообщения `{pub}` в `me` отклоняются.

Сообщение `{get what="desc"}` в `me` автоматически отвечает сообщением `{meta}`, содержащим раздел `desc` с параметрами топика (см. введение в раздел [Топики](#топики)). Параметры `public` топика `me` — это данные, которые пользователь хочет показать своим контактам. Изменение их изменяет `public` не только для топика `me`, но и везде, где показывается `public` пользователя, например `public` всех peer to peer топиков пользователя.

Сообщение `{get what="sub"}` в `me` отличается от любого другого топика, так как оно возвращает список топиков, на которые подписан текущий пользователь, в отличие от ожидаемой подписки пользователя на `me`.
* seq: числовой ID, выданный сервером, последнего сообщения в топике
* recv: значение seq, самостоятельно сообщенное текущим пользователем как полученное
* read: значение seq, самостоятельно сообщенное текущим пользователем как прочитанное
* seen: для P2P подписок сообщается временная метка последнего присутствия пользователя и строка User Agent
* when: временная метка, когда пользователь был последний раз онлайн
* ua: строка user agent клиентского программного обеспечения пользователя, использованного последним

Сообщение `{get what="data"}` в `me` отклоняется.

### `fnd` и теги: Поиск пользователей и топиков

Топик `fnd` автоматически создается для каждого пользователя во время создания аккаунта. Он служит эндпоинтом для обнаружения других пользователей и групповых топиков. Пользователи и групповые топики могут быть обнаружены по `tags`. Теги опционально назначаются во время создания топика или пользователя, затем могут быть обновлены с помощью `{set what="tags"}` против топика `me` или группового топика.

Тег — это произвольная строка Unicode без учета регистра (принудительно преобразуется в нижний регистр на сервере) длиной до 96 символов, которая может содержать символы из классов/категорий Unicode `Letter` и `Number` [classes/categories](https://en.wikipedia.org/wiki/Unicode_character_property#General_Category), а также любые из следующих символов ASCII: `_`, `.`, `+`, `-`, `@`, `#`, `!`, `?`.

Тег может иметь префикс, который служит пространством имен. Префикс — это строка из 2-16 символов, которая начинается с буквы [a-z] и может содержать строчные буквы ASCII и цифры, за которыми следует двоеточие `:`, например, тег телефона с префиксом `tel:+14155551212` или тег email с префиксом `email:alice@example.com`. Некоторые теги с префиксом опционально принудительно уникальны. В этом случае только один пользователь или топик может иметь такой тег. Некоторые теги могут быть принудительно неизменяемыми для пользователя, т.е. попытки пользователя добавить или удалить неизменяемый тег будут отклонены сервером.

Теги индексируются на стороне сервера и используются для обнаружения пользователей и топиков. Поиск возвращает пользователей и топики, отсортированные по количеству совпадающих тегов в порядке убывания.

Чтобы найти пользователей или топики, пользователь устанавливает либо параметр `public`, либо `private` топика `fnd` в поисковый запрос (см. [Язык запросов](#язык-запросов)), затем отправляет запрос `{get topic="fnd" what="sub"}`. Если установлены и `public`, и `private`, используется запрос `public`. Запрос `private` сохраняется между сессиями и устройствами, т.е. все сессии пользователя видят тот же запрос `private`. Значение запроса `public` является эфемерным, т.е. оно не сохраняется в базе данных и не передается между сессиями пользователя. Запрос `private` предназначен для больших запросов, которые не часто меняются, например, поиск совпадений для всех в списке контактов пользователя на мобильном телефоне. Запрос `public` предназначен для коротких и конкретных запросов, например, поиск какого-то топика или пользователя, которого нет в списке контактов.

Система отвечает сообщением `{meta}` с разделом `sub`, перечисляющим детали найденных пользователей или топиков, отформатированных как подписки.

Топик `fnd` доступен только для чтения. Сообщения `{pub}` в `fnd` отклоняются.

_В НАСТОЯЩЕЕ ВРЕМЯ НЕ ПОДДЕРЖИВАЕТСЯ_ Когда новый пользователь регистрируется с тегами, соответствующими данному запросу, топик `fnd` получит уведомление `{pres}` для нового пользователя.

[Плагины](../pbx) поддерживают службу `Find`, которая может использоваться для замены поиска по умолчанию на пользовательский.

#### Язык запросов

Язык запросов Tinode используется для определения поисковых запросов для поиска пользователей и топиков. Запрос — это строка, содержащая атомарные термины, разделенные пробелами или запятыми. Отдельные термины запроса сопоставляются с тегами пользователя или топика. Отдельные термины могут быть написаны на языке RTL, но запрос в целом анализируется слева направо. Пробелы обрабатываются как оператор `AND`, запятые (а также запятые, перед которыми и/или после которых стоит пробел) как оператор `OR`. Порядок операторов игнорируется: все теги `AND` группируются вместе, все теги `OR` группируются вместе. `OR` имеет приоритет над `AND`: если тег предшествует или следует за запятой, это тег `OR`, в противном случае `AND`. Например, `aaa bbb, ccc` (`aaa AND bbb OR ccc`) интерпретируется как `(bbb OR ccc) AND aaa`.

Термины запроса, содержащие пробелы, должны преобразовывать пробелы в подчеркивания ` ` -> `_`, например `new york` -> `new_york`.

**Некоторые примеры:**
* `flowers`: найти топики или пользователей, которые содержат тег `flowers`.
* `flowers travel`: найти топики или пользователей, которые содержат оба тега `flowers` и `travel`.
* `flowers, travel`: найти топики или пользователей, которые содержат либо тег `flowers`, либо `travel` (или оба).
* `flowers travel, puppies`: найти топики или пользователей, которые содержат `flowers` и либо `travel`, либо `puppies`, т.е. `(travel OR puppies) AND flowers`.
* `flowers, travel puppies, kittens`: найти топики или пользователей, которые содержат один из `flowers`, `travel`, `puppies` или `kittens`, т.е. `flowers OR travel OR puppies OR kittens`. Пробел между `travel` и `puppies` обрабатывается как `OR` из-за того, что `OR` имеет приоритет над `AND`.

#### Инкрементальные обновления запросов

_В НАСТОЯЩЕЕ ВРЕМЯ НЕ ПОДДЕРЖИВАЕТСЯ_ Запросы, особенно `fnd.private`, могут быть произвольно большими, ограниченными только пределами размера сообщения и пределами размера запроса в базовой базе данных. Вместо переписывания всего запроса для добавления или удаления термина, термины могут быть добавлены или удалены инкрементально.

Запрос инкрементального обновления обрабатывается слева направо. Он может содержать один и тот же термин несколько раз, т.е. `-a_tag+a_tag` является допустимым запросом.

#### Переписывание запросов

Поиск пользователей по логину, телефону или email требует, чтобы термины запроса были написаны с префиксами, т.е. `email:alice@example.com` вместо `alice@example.com`. Это может представлять проблему для конечных пользователей, поскольку требует от них изучения языка запросов. Tinode решает эту проблему, реализуя _переписывание запросов_ на сервере: если термин запроса (тег) не содержит префикса, сервер переписывает его, добавляя соответствующий префикс. В запросах к `fnd.public` исходный термин также сохраняется (запрос `alice@example.com` переписывается как `email:alice@example.com OR alice@example.com`), в запросах к `fnd.private` сохраняется только переписанный термин (`alice@example.com` переписывается как `email:alice@example.com`). Все термины, которые выглядят как email, например, `alice@example.com`, переписываются в `email:alice@example.com OR alice@example.com`. Термины, которые выглядят как номера телефонов, преобразуются в [E.164](https://en.wikipedia.org/wiki/E.164) и также переписываются как `tel:+14155551212 OR +14155551212`. Кроме того, в запросах к `fnd.public` все другие термины без префикса, которые выглядят как логины, переписываются как логины: `alice` -> `basic:alice OR alice`.

Как описано выше, теги, которые выглядят как номера телефонов, преобразуются в формат E.164. Такое преобразование требует кода страны ISO 3166-1 alpha-2. Следующая логика используется при преобразовании тегов номеров телефонов в E.164:
* Если тег уже содержит код страны, он используется как есть: `+1(415)555-1212` -> `+14155551212`.
* Если тег не имеет префикса, код страны берется из значения локали, установленного клиентом в поле `lang` сообщения `{hi}`.
* Если клиент не предоставил код в `hi.lang`, код страны берется из поля `default_country_code` файла `tinode.conf`.
* Если `default_country_code` не установлен в `tinode.conf`, используется код страны `US`.

#### Возможные случаи использования
* Ограничение пользователей организациями.
  Пользователю может быть назначен неизменяемый тег(и), который обозначает организацию, к которой принадлежит пользователь. Когда пользователь ищет других пользователей или топики, поиск может быть ограничен, чтобы всегда содержать тег. Этот подход может использоваться для сегментации пользователей по организациям с ограниченной видимостью друг друга.

* Поиск по географическому местоположению.
  Клиентское программное обеспечение может периодически назначать тег [geohash](https://en.wikipedia.org/wiki/Geohash) пользователю на основе текущего местоположения. Поиск пользователей в данной области означал бы сопоставление по тегам geohash.

* Поиск по числовому диапазону, например, диапазону возрастов.
  Подход аналогичен geohashing. Весь диапазон чисел покрывается наименьшей возможной степенью 2, например, диапазон человеческих возрастов покрывается 2<sup>7</sup>=128 лет. Весь диапазон разделяется на две половины: диапазон 0-63 обозначается как 0, 64-127 как 1. Операция повторяется с каждым поддиапазоном, т.е. 0-31 это 00, 32-63 это 01, 0-15 это 000, 32-47 это 010. После завершения возраст 30 будет принадлежать следующим диапазонам: 0 (0-63), 00 (0-31), 001 (16-31), 0011 (24-31), 00111 (28-31), 001111 (30-31), 0011110 (30). Пользователю 30 лет назначается несколько тегов для указания возраста, т.е. `age:00111`, `age:001111` и `age:0011110`. Технически все 7 тегов могут быть назначены, но обычно это непрактично. Чтобы запросить кого-либо в диапазоне возрастов 28-35, преобразуйте диапазон в минимальное количество тегов: `age:00111` (28-31), `age:01000` (32-35). Этот запрос будет соответствовать пользователю 30 лет по тегу `age:00111`.


### Peer to Peer топики

Peer to peer (P2P) топики представляют каналы связи строго между двумя пользователями. Имя топика различается для каждого из двух участников. Каждый из них видит имя топика как ID пользователя другого участника: `usr`, за которым следует base64 URL-кодированный ID пользователя. Например, если два пользователя `usrOj0B3-gSBSs` и `usrIU_LOVwRNsc` начинают P2P топик, первый увидит его как `usrIU_LOVwRNsc`, второй как `usrOj0B3-gSBSs`. P2P топик не имеет владельца.

P2P топик создается одним пользователем, подписывающимся на топик с именем, равным ID другого пользователя. Например, пользователь `usrOj0B3-gSBSs` может установить P2P топик с пользователем `usrIU_LOVwRNsc`, отправив `{sub topic="usrIU_LOVwRNsc"}`. Tinode ответит пакетом `{ctrl}` с именем вновь созданного топика, как описано выше. Другой пользователь получит сообщение `{pres}` в топике `me` с обновленными разрешениями доступа.

Параметр 'public' P2P топиков зависит от пользователя. Например, P2P топик между пользователями A и B покажет 'public' пользователя A пользователю B и наоборот. Если пользователь обновляет 'public', все P2P топики пользователя автоматически обновят 'public' тоже.

Параметр 'private' P2P топика определяется каждым участником индивидуально, как и для любого другого типа топика.

### Групповые топики

Групповой топик представляет канал связи между несколькими пользователями. Имя группового топика — это `grp` или `chn`, за которым следует строка символов из набора base64 URL-кодирования. Нельзя делать никаких предположений о внутренней структуре или длине имени группы.

Групповые топики поддерживают ограниченное количество подписчиков (контролируется параметром `max_subscriber_count` в файле конфигурации) с разрешениями доступа каждого подписчика, управляемыми индивидуально. Групповые топики также могут быть включены для поддержки любого количества пользователей только для чтения — `readers`. Все `readers` имеют одинаковые разрешения доступа. Групповые топики с включенными `readers` называются `channels`.

Групповой топик создается путем отправки сообщения `{sub}` с полем топика, установленным в строку `new` или `nch`, опционально за которой следуют любые символы, например `new` или `newAbC123` эквивалентны. Tinode ответит сообщением `{ctrl}` с именем вновь созданного топика, т.е. `{sub topic="new"}` отвечает `{ctrl topic="grpmiKBkQVXnm3P"}`. Если создание топика не удалось, ошибка сообщается на исходное имя топика, т.е. `new` или `newAbC123`. Пользователь, создавший топик, становится владельцем топика. Владение может быть передано другому пользователю сообщением `{set}`, но один пользователь должен оставаться владельцем все время.

Топик `channel` отличается от группового топика без канала следующим образом:

* Топик канала создается путем отправки `{sub topic="nch"}`. Отправка `{sub topic="new"}` создаст групповой топик без включения функциональности канала.
* Отправка `{sub topic="chnAbC123"}` создаст подписку `reader` на канал. Групповой топик без канала отклонит такой запрос на подписку.
* При поиске топиков с помощью [`fnd`](#fnd-и-теги-поиск-пользователей-и-топиков) каналы будут показывать адреса с префиксами `chn`, групповой топик без канала будет показывать с префиксами `grp`.
* Сообщения, полученные читателями на каналах, не имеют поля `From`. Обычные подписчики будут получать сообщения с `From`, содержащим ID отправителя.
* Разрешения по умолчанию для канала и группового топика без канала различаются: групповой топик канала не предоставляет никаких разрешений вообще.
* Присоединение или выход подписчика из топика (обычного или с включенным каналом) генерирует сообщение `{pres}` всем другим подписчикам, которые в настоящее время находятся в присоединенном состоянии с топиком и имеют соответствующие разрешения. Присоединение или выход читателя из канала не генерирует сообщение `{pres}`.

### Топик `sys`

Топик `sys` служит всегда доступным каналом связи с системными администраторами. Обычный пользователь без прав root не может подписаться на `sys`, но может публиковать в него без подписки. Существующие клиенты используют этот канал для сообщения о злоупотреблениях, отправляя сообщение `{pub}` в формате Drafty с отчетом в виде JSON вложения. Пользователь root может подписаться на топик `sys`. После подписки пользователь root будет получать сообщения, отправленные в топик `sys` другими пользователями.

## Использование ID сообщений, выданных сервером

Tinode предоставляет базовую поддержку кэширования сообщений `{data}` на стороне клиента в виде последовательных ID сообщений, выданных сервером. Клиент может запросить последний ID сообщения из топика, отправив сообщение `{get what="desc"}`. Если возвращенный ID больше, чем ID последнего полученного сообщения, клиент знает, что в топике есть непрочитанные сообщения и их количество. Клиент может получить эти сообщения, используя сообщение `{get what="data"}`. Клиент также может разбивать на страницы получение истории, используя ID сообщений.

## User Agent и уведомления о присутствии

Пользователь сообщается как находящийся онлайн, когда одна или несколько сессий пользователя присоединены к топику `me`. Клиентское программное обеспечение идентифицирует себя серверу, используя поле `ua` (user agent) сообщения `{login}`. _User agent_ публикуется в сообщениях `{meta}` и `{pres}` следующим образом:

* Когда первая сессия пользователя присоединяется к `me`, _user agent_ из этой сессии транслируется в сообщении `{pres what="on" ua="..."}`.
* Когда несколько сессий пользователя присоединены к `me`, _user agent_ сессии, где произошло самое последнее действие, сообщается в `{pres what="ua" ua="..."}`; 'действие' в этом контексте означает любое сообщение, отправленное клиентом. Чтобы избежать потенциально избыточного трафика, изменения user agent транслируются не чаще одного раза в минуту.
* Когда последняя сессия пользователя отсоединяется от `me`, _user agent_ из этой сессии записывается вместе с временной меткой; user agent транслируется в сообщении `{pres what="off"  ua="..."}` и впоследствии сообщается как последняя временная метка онлайн и user agent.

Пустой `ua=""` _user agent_ не сообщается. Т.е. если пользователь присоединяется к `me` с непустым _user agent_, а затем делает это с пустым, изменение не сообщается. Пустой _user agent_ может быть запрещен в будущем.

## Поля Trusted, Public, Private, Auxiliary

Топики имеют поля `trusted`, `public`, `aux`, подписки имеют поля `private`. Основное различие между этими полями заключается в контроле доступа:

* `trusted`: доступно для записи пользователями `ROOT`, доступно для чтения всем.
* `public`: доступно для записи `owner` или пользователем, доступно для чтения всем.
* `aux`: доступно для записи администраторами топика, доступно для чтения подписчиками.
* `private`: доступно для чтения и записи только пользователем, который создал подписку.

В общем, поля определяются приложением. Сервер не применяет какую-либо конкретную структуру этих полей, за исключением топика `fnd`. В то же время клиентское программное обеспечение должно использовать тот же формат по причинам совместимости. Следующие разделы описывают формат этих полей, как они реализованы всеми официальными клиентами.

Хотя это еще не применяется, если стороннее приложение определяет пользовательские ключи, имена ключей должны начинаться с `x-`, за которым следует полностью квалифицированное доменное имя приложения, например `x-example.com-value: "abc"`. Поля должны содержать только примитивные типы, т.е. `string`, `boolean`, `number` или `null`.

### Trusted

Формат опционального поля `trusted` в групповых и peer to peer топиках — это набор пар ключ-значение; топики `fnd` и `sys` не имеют `trusted`. Поле доступно для записи пользователями `ROOT`, доступно для чтения всем, кто имеет доступ к топику или пользователю. Следующие опциональные ключи в настоящее время определены:
```js
trusted: {
  verified: true, // boolean, индикатор проверенного/заслуживающего доверия пользователя или топика.
  staff: true,    // boolean, индикатор того, что пользователь или топик
                  // является частью/принадлежит администрации сервера.
  danger: true    // boolean, индикатор того, что пользователь или топик ненадежны.
}
```

### Public

Формат поля `public` в групповых, peer to peer, системных топиках ожидается как [theCard](./thecard.md). Поле доступно для записи пользователем для пользователей, владельцем топика для топиков. Поле доступно для чтения всем, кто имеет доступ к топику или пользователю.

Топик `fnd` ожидает, что `public` будет строкой, представляющей [поисковый запрос](#язык-запросов)).

### Private

Формат поля `private` в групповых и peer to peer топиках — это набор пар ключ-значение. Поле доступно для записи и чтения только пользователем. Следующие ключи в настоящее время определены:
```js
private: {
  comment: "some comment", // string, опциональный комментарий пользователя о топике или пользователе-собеседнике
  arch: true, // boolean, индикатор того, что топик заархивирован пользователем, т.е.
              // не должен отображаться в UI с другими незаархивированными топиками.
  accepted: "JRWS" // string, режим 'given', принятый пользователем.
}
```

Топик `fnd` ожидает, что `private` будет строкой, представляющей [поисковый запрос](#язык-запросов)).

### Auxiliary

Формат поля `aux` — это набор пар ключ-значение. `aux` доступно для записи администраторами топика и доступно для чтения всеми подписчиками топика. Следующие ключи в настоящее время определены:

```js
aux: {
  pins: [1001, 23456] // массив целых ID сообщений для закрепления в верхней части списка сообщений.
}
```

## Формат содержимого

Формат поля `content` в `{pub}` и `{data}` определяется приложением, и поэтому сервер не применяет какую-либо конкретную структуру поля. В то же время клиентское программное обеспечение должно использовать тот же формат по причинам совместимости. В настоящее время поддерживаются следующие два типа `content`:
* Простой текст
* [Drafty](./drafty.md)

Если используется Drafty, должен быть установлен заголовок сообщения `"head": {"mime": "text/x-drafty"}`.


## Обработка больших файлов вне полосы

Большие файлы создают проблемы при отправке в полосе по нескольким причинам:
* ограничения на хранение в базе данных, так как сообщения в полосе хранятся в полях базы данных
* сообщения в полосе должны быть полностью загружены как часть загрузки истории чата

Tinode предоставляет два эндпоинта для обработки больших файлов: `/v0/file/u` для загрузки файлов и `v0/file/s` для скачивания. Эндпоинты требуют, чтобы клиент предоставил как [API ключ](#подключение-к-серверу), так и учетные данные для входа. Сервер проверяет учетные данные в следующем порядке:

**Учетные данные для входа**
* HTTP заголовок `Authorization` (https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization)
* URL параметры запроса `auth` и `secret` (/v0/file/s/abcdefg.jpeg?auth=...&secret=...)
* Значения формы `auth` и `secret`
* Cookies `auth` и `secret`

### Загрузка

Чтобы загрузить файл, сначала создайте запрос multipart RFC 2388, затем отправьте его на сервер, используя HTTP POST. Сервер отвечает на запрос либо с `307 Temporary Redirect` с новым URL загрузки, либо с `200 OK` и сообщением `{ctrl}` в теле ответа:

```js
ctrl: {
  params: {
    url: "/v0/file/s/mfHLxDWFhfU.pdf"
  },
  code: 200,
  text: "ok",
  ts: "2018-07-06T18:47:51.265Z"
}
```
Если возвращается `307 Temporary Redirect`, клиент должен повторить загрузку по предоставленному URL. URL, возвращенный в ответе `307`, должен использоваться только для этой одной загрузки. Все последующие загрузки должны сначала попробовать URL по умолчанию.

`ctrl.params.url` содержит путь к загруженному файлу на текущем сервере. Это может быть либо полный путь, например `/v0/file/s/mfHLxDWFhfU.pdf`, относительный путь, например `./mfHLxDWFhfU.pdf`, или просто имя файла `mfHLxDWFhfU.pdf`. Все, кроме полного пути, интерпретируется относительно эндпоинта *скачивания* по умолчанию `/v0/file/s/`. Например, если возвращается `mfHLxDWFhfU.pdf`, то файл находится по адресу `http(s)://current-tinode-server/v0/file/s/mfHLxDWFhfU.pdf`.

После получения URL файла, либо сразу, либо после следования редиректу, клиент может использовать URL для отправки сообщения `{pub}` с загруженным файлом в качестве вложения, или, если файл является изображением, как изображение аватара для топика или профиля пользователя (см. [theCard](./thecard.md)). Например, URL может быть использован в поле `pub.content`, отформатированном как [Drafty](./drafty.md):

```js
{
  pub: {
    id: "121103",
    topic: "grpnG99YhENiQU",
    head: {
      mime: "text/x-drafty"
    },
    content: {
      ent: [
      {
        data: {
        mime: "image/jpeg",
        name: "roses-are-red.jpg",
        ref:  "/v0/file/s/sJOD_tZDPz0.jpg",
        size: 437265
      },
        tp: "EX"
      }
    ],
    fmt: [
      {
        at: -1,
      key:0,
      len:1
      }
    ]
    }
  },
  extra: {
    attachments: ["/v0/file/s/sJOD_tZDPz0.jpg"]
  }
}
```

Важно перечислить используемые URL в поле `extra: attachments[...]`. Сервер Tinode использует это поле для поддержания счетчика использования загруженного файла. Как только счетчик падает до нуля для данного файла (например, потому что сообщение с общим URL было удалено или потому что клиент не включил URL в поле `extra.attachments`), сервер выполнит сборку мусора файла. Должны использоваться только относительные URL. Абсолютные URL в поле `extra.attachments` игнорируются. Значение URL должно быть `ctrl.params.url`, возвращенным в ответе на загрузку.

### Скачивание

Эндпоинт обслуживания `/v0/file/s` обслуживает файлы в ответ на HTTP GET запросы. Клиент должен оценивать относительные URL относительно этого эндпоинта, т.е. если он получает URL `mfHLxDWFhfU.pdf` или `./mfHLxDWFhfU.pdf`, он должен интерпретировать его как путь `/v0/file/s/mfHLxDWFhfU.pdf` на текущем HTTP сервере Tinode.

_Важно!_ В качестве меры безопасности клиент не должен отправлять учетные данные безопасности, если URL скачивания является абсолютным и ведет на другой сервер.

## Push-уведомления

Tinode использует адаптеры времени компиляции для обработки push-уведомлений. Сервер поставляется с адаптерами [Tinode Push Gateway](../server/push/tnpg/), [Google FCM](https://firebase.google.com/docs/cloud-messaging/) и `stdout`. Tinode Push Gateway и Google FCM поддерживают Android с [Play Services](https://developers.google.com/android/guides/overview) (может не поддерживаться некоторыми китайскими телефонами), устройства iOS и все основные веб-браузеры, кроме Safari. Адаптер `stdout` на самом деле не отправляет push-уведомления. Он в основном полезен для отладки, тестирования и логирования. Другие типы push-уведомлений, такие как [TPNS](https://intl.cloud.tencent.com/product/tpns), могут обрабатываться путем написания соответствующих адаптеров.

Если вы пишете пользовательский плагин, полезная нагрузка уведомления следующая:
```js
{
  topic: "grpnG99YhENiQU", // Топик, который получил сообщение.
  xfrom: "usr2il9suCbuko", // ID пользователя, который отправил сообщение.
  ts: "2019-01-06T18:07:30.038Z", // временная метка сообщения в формате RFC3339.
  seq: "1234", // последовательный ID сообщения (целочисленное значение, отправляемое как текст).
  mime: "text/x-drafty", // опциональный MIME-тип сообщения.
  content: "Lorem ipsum dolor sit amet, consectetur adipisci", // Первые 80 символов содержимого сообщения как обычный текст.
}
```

### Tinode Push Gateway

Tinode Push Gateway (TNPG) — это проприетарная служба Tinode, которая отправляет push-уведомления от имени Tinode. Внутренне она использует Google FCM и, таким образом, поддерживает те же платформы, что и FCM. Основное преимущество использования TNPG перед FCM — простота конфигурации: мобильным клиентам не нужно перекомпилироваться, все, что нужно, — это [обновление конфигурации](../server/push/tnpg/) на сервере.

### Google FCM

[Google FCM](https://firebase.google.com/docs/cloud-messaging/) поддерживает Android с [Play Services](https://developers.google.com/android/guides/overview), устройства iPhone и iPad, а также все основные веб-браузеры, кроме Safari. Для использования FCM мобильные клиенты (iOS, Android) должны быть перекомпилированы с учетными данными, полученными от Google. Подробности см. в [инструкциях](../server/push/fcm/).

### Stdout

Адаптер `stdout` в основном полезен для отладки и логирования. Он записывает полезную нагрузку push в `STDOUT`, где она может быть перенаправлена в файл или прочитана другим процессом.

## Видеозвонки

[См. отдельный документ](call-establishment.md).

## Превью ссылок

Tinode предоставляет опциональную службу, которая помогает клиентским приложениям генерировать превью ссылок (URL) для включения в сообщения. Эндпоинт этой службы (если включен) находится по адресу `/v0/urlpreview`. Служба принимает один параметр `url`:

```
/v0/urlpreview?url=https%3A%2F%2Ftinode.co
```
Первые несколько килобайт документа по данному URL извлекаются путем отправки HTTP(S) GET запроса. Если возвращенный документ имеет content-type `text/html`, HTML анализируется для получения заголовка страницы, описания и URL изображения. Результат форматируется как JSON и возвращается как

```json
{"title": "Page title", "description": "This is a page description", "image_url": "https://tinode.co/img/logo64x64.png"}
```

Служба превью ссылок требует аутентификации. Это точно такая же аутентификация, как для [Больших файлов вне полосы](#обработка-больших-файлов-вне-полосы).

## Сообщения

Сообщение — это логически связанный набор данных. Сообщения передаются как JSON-форматированный текст UTF-8.

Все сообщения от клиента к серверу могут иметь опциональное поле `id`. Оно устанавливается клиентом как средство получения подтверждения от сервера о том, что сообщение было получено и обработано. `id` ожидается как уникальная строка для сессии, но это может быть любая строка. Сервер не пытается интерпретировать его, кроме проверки валидности JSON. `id` возвращается сервером без изменений, когда он отвечает на сообщение клиента.

Сервер требует строго валидный JSON, включая двойные кавычки вокруг имен полей. Для краткости обозначение ниже опускает двойные кавычки вокруг имен полей, а также внешние фигурные скобки. Примеры используют комментарии `//` только для выразительности. Комментарии не могут использоваться в фактическом общении с сервером.

Для сообщений, которые обновляют данные, определенные приложением, такие как поля `private` или `public` в `{set}`, когда данные на стороне сервера нужно очистить, используйте строку с одним символом Unicode DEL "&#x2421;" (`\u2421`). Т.е. отправка `"public": null` не очистит поле, но отправка `"public": "␡"` очистит.

Любые нераспознанные поля молча игнорируются сервером.

### Сообщения от клиента к серверу

Каждое сообщение от клиента к серверу содержит основную полезную нагрузку, описанную в разделах ниже, и опциональное поле верхнего уровня `extra`:
```js
{
  abc: { ... }, // Основная полезная нагрузка, см. разделы ниже.
  extra: {
    attachments: ["/v0/file/s/sJOD_tZDPz0.jpg"], // Массив вложений вне полосы, которые должны быть исключены из GC.
    obo: "usr2il9suCbuko", // Альтернативный ID пользователя, установленный пользователем root (obo = On Behalf Of).
    authlevel: "auth"  // Измененный уровень аутентификации, установленный пользователем root.
  }
}
```
Массив `attachments` перечисляет URL файлов, загруженных вне полосы. Такое перечисление увеличивает счетчик использования этих файлов. Как только счетчик использования падает до 0, файлы будут автоматически удалены.
`obo` (On Behalf Of) может быть установлен пользователем `root`. Если `obo` установлен, сервер будет обрабатывать сообщение так, как если бы оно пришло от указанного пользователя, в отличие от фактического отправителя.
`authlevel` является дополнением к `obo` и разрешает установку пользовательского уровня аутентификации для пользователя. Уровень `"auth"` используется, если поле не установлено.

#### `{hi}`

Сообщение рукопожатия, которое клиент использует для информирования сервера о своей версии и user agent. Это сообщение должно быть первым, которое клиент отправляет на сервер. Сервер отвечает `{ctrl}`, который содержит сборку сервера `build`, версию протокола передачи `ver`, ID сессии `sid` в случае long polling, а также ограничения сервера, все в `ctrl.params`.

```js
hi: {
  id: "1a2b3",     // string, ID сообщения, предоставленный клиентом, опционально
  ver: "0.15.8-rc2", // string, версия протокола передачи, поддерживаемая клиентом, требуется
  ua: "JS/1.0 (Windows 10)", // string, user agent, идентифицирующий клиентское программное обеспечение,
                   // опционально
  dev: "L1iC2...dNtk2", // string, уникальное значение, которое идентифицирует это конкретное
                   // подключенное устройство для целей push-уведомлений; не
                   // интерпретируется сервером.
                   // см. [Поддержка push-уведомлений](#push-уведомления); опционально
  platf: "android", // string, базовая ОС для целей push-уведомлений, одна из
                   // "android", "ios", "web"; если отсутствует, сервер попытается определить
                   // платформу из строки user agent; опционально
  lang: "en-US"    // человеческий язык клиентского устройства; опционально
}
```
User agent `ua` ожидается следовать рекомендации [RFC 7231 section 5.5.3](http://tools.ietf.org/html/rfc7231#section-5.5.3), но формат не применяется. Сообщение может быть отправлено более одного раза для обновления значений `ua`, `dev` и `lang`. Если отправлено более одного раза, поле `ver` второго и последующих сообщений должно быть либо неизменным, либо не установлено.

#### `{acc}`

Сообщение `{acc}` создает пользователей или обновляет `tags` или учетные данные аутентификации `scheme` и `secret` существующих пользователей. Чтобы создать нового пользователя, установите `user` в строку `new`, опционально за которой следует любая последовательность символов, например `newr15gsr`. Либо аутентифицированная, либо анонимная сессия может отправить сообщение `{acc}` для создания нового пользователя. Чтобы обновить данные аутентификации или проверить учетные данные текущего пользователя, оставьте `user` неустановленным.

Сообщение `{acc}` **не может** использоваться для изменения `desc` или `cred` существующего пользователя. Вместо этого обновите топик `me` пользователя.

```js
acc: {
  id: "1a2b3", // string, ID сообщения, предоставленный клиентом, опционально
  user: "newABC123", // string, "new" опционально за которым следуют любые символы для создания нового пользователя,
              // по умолчанию: текущий пользователь, опционально
  token: "XMgS...8+BO0=", // string, токен аутентификации для использования в запросе, если
               // сессия не аутентифицирована, опционально
  // Временные параметры аутентификации для одноразовых действий, таких как сброс пароля.
  tmpscheme: "code", // имя временной схемы аутентификации
  tmpsecret: "XMgS...8+BO0=", // временный секрет аутентификации
  status: "ok", // изменить статус пользователя; значение по умолчанию отсутствует, опционально.
  authlevel: "auth", // уровень аутентификации пользователя, когда UserID установлен и не равен
              // текущему пользователю; Либо "", "auth" или "anon"; по умолчанию: ""
  scheme: "basic", // схема аутентификации для этого аккаунта, требуется;
               // "basic" и "anon" в настоящее время поддерживаются для создания аккаунта.
  secret: base64encode("username:password"), // string, base64-кодированный секрет для выбранной
              // схемы аутентификации; для удаления схемы используйте строку с одним символом DEL
              // Unicode "\u2421"; "token" и "basic" не могут быть удалены
  login: true, // boolean, использовать вновь созданный аккаунт для аутентификации текущей сессии,
              // т.е. создать аккаунт и немедленно использовать его для входа.
  tags: ["alice johnson",... ], // массив тегов для обнаружения пользователя; см. топик 'fnd' для
              // подробностей, опционально (если отсутствует, пользователь не будет обнаруживаемым, кроме
              // как по логину)
  cred: [  // учетные данные аккаунта, которые требуют проверки, такие как email или номер телефона.
    {
      meth: "email", // string, метод проверки, например "email", "tel", "recaptcha", и т.д.
      val: "alice@example.com", // string, учетные данные для проверки, такие как email или телефон
      resp: "178307", // string, ответ проверки, опционально
      params: { ... } // параметры, специфичные для метода проверки, опционально
    },
  ...
  ],

  desc: {  // object, данные инициализации пользователя, тесно соответствующие инициализации таблицы;
           // используется только при создании аккаунта; опционально
    defacs: {
      auth: "JRWS", // string, режим доступа по умолчанию для peer to peer разговоров
                   // между этим пользователем и другими аутентифицированными пользователями
      anon: "N"  // string, режим доступа по умолчанию для peer to peer разговоров
                 // между этим пользователем и анонимными (не аутентифицированными) пользователями
    }, // Режим доступа по умолчанию для peer to peer топиков пользователя
    public: { ... }, // полезная нагрузка, определенная приложением, для описания пользователя,
                // доступна всем
    private: { ... } // частная полезная нагрузка, определенная приложением, доступна только пользователю
                // через топик 'me'
  }
}
```

Сервер отвечает сообщением `{ctrl}` с `params`, содержащим детали нового аккаунта пользователя, такие как ID пользователя и, в случае `login: true`, токен аутентификации. Если `desc.defacs` отсутствует, сервер назначит разрешения доступа по умолчанию сервера новому аккаунту.

Единственные поддерживаемые схемы аутентификации для создания аккаунта — это `basic` и `anonymous`.

#### `{login}`

Вход используется для аутентификации текущей сессии.

```js
login: {
  id: "1a2b3",     // string, ID сообщения, предоставленный клиентом, опционально
  scheme: "basic", // string, схема аутентификации; "basic",
                   // "token" и "reset" в настоящее время поддерживаются
  secret: base64encode("username:password"), // string, base64-кодированный секрет для выбранной
                  // схемы аутентификации, требуется
  cred: [
    {
      meth: "email", // string, метод проверки, например "email", "tel", "captcha", и т.д., требуется
      resp: "178307" // string, ответ проверки, требуется
    },
  ...
  ],   // ответ на запрос проверки учетных данных, опционально
}
```

Сервер отвечает на пакет `{login}` сообщением `{ctrl}`. `params` сообщения содержит ID вошедшего пользователя как `user`. `token` содержит зашифрованную строку, которая может использоваться для аутентификации. Время истечения токена передается как `expires`.

#### `{sub}`

Пакет `{sub}` выполняет следующие функции:
* создание нового топика
* подписка пользователя на существующий топик
* присоединение сессии к ранее подписанному топику
* получение данных топика

Пользователь создает новый групповой топик, отправляя пакет `{sub}` с полем `topic`, установленным в `new12321` (обычный топик) или `nch12321` (канал), где `12321` обозначает любую строку, включая пустую строку. Сервер создаст топик и ответит сессии именем вновь созданного топика.

Пользователь создает новый peer to peer топик, отправляя пакет `{sub}` с `topic`, установленным в ID пользователя собеседника.

Пользователь всегда подписывается на вновь созданный топик, и сессия присоединяется к вновь созданному топику.

Если у пользователя не было связи с топиком, отправка пакета `{sub}` создает ее. Подписка означает установление связи между пользователем сессии и топиком, где ранее не было связи.

Присоединение (прикрепление к) топику означает для сессии начало потребления содержимого из топика. Сервер автоматически различает подписку и присоединение/прикрепление на основе контекста: если у пользователя не было предварительной связи с топиком, сервер подписывает пользователя, а затем присоединяет текущую сессию к топику. Если связь существовала, сервер только присоединяет сессию к топику. При подписке сервер проверяет разрешения доступа пользователя против списка контроля доступа топика. Он может предоставить немедленный доступ, отказать в доступе, может сгенерировать запрос на одобрение от менеджеров топика.

Сервер отвечает на `{sub}` с `{ctrl}`.

Сообщение `{sub}` может включать поля `get` и `set`, которые отражают сообщения `{get}` и `{set}`. Если включены, сервер будет обрабатывать их как последующие сообщения `{set}` и `{get}` на том же топике. Если `get` установлен, ответ может включать сообщения `{meta}` и `{data}`.


```js
sub: {
  id: "1a2b3",  // string, ID сообщения, предоставленный клиентом, опционально
  topic: "me",  // топик, на который нужно подписаться или присоединиться
  bkg: true,    // запрос на присоединение к топику выдан автоматическим агентом, сервер должен задержать отправку
                // уведомлений о присутствии, потому что агент ожидается отключиться очень быстро
  // Объект с данными инициализации топика, только для новых топиков и новых
  // подписок, отражает сообщение {set}
  set: {
  // Параметры нового топика, отражает {set desc}
    desc: {
      defacs: {
        auth: "JRWS", // string, доступ по умолчанию для новых аутентифицированных подписчиков
        anon: "N"    // string, доступ по умолчанию для новых анонимных (не аутентифицированных)
                     // подписчиков
      }, // Режим доступа по умолчанию для нового топика
      trusted: { ... }, // полезная нагрузка, определенная приложением, назначенная системной администрацией
      public: { ... }, // полезная нагрузка, определенная приложением, для описания топика
      private: { ... } // частное содержимое, определенное приложением, для каждого пользователя
    }, // object, опционально

    // Параметры подписки, отражает {set sub}. 'sub.user' должен быть пустым
    sub: {
      mode: "JRWS", // string, запрошенный режим доступа, опционально;
                   // по умолчанию: определенный сервером
    }, // object, опционально

    tags: [ // массив строк, обновление тегов (см. описание топика fnd), опционально.
        "email:alice@example.com", "tel:1234567890"
    ],

    cred: { // обновление учетных данных, опционально.
      meth: "email", // string, метод проверки, например "email", "tel", "recaptcha", и т.д.
      val: "alice@example.com", // string, учетные данные для проверки, такие как email или телефон
      resp: "178307", // string, ответ проверки, опционально
      params: { ... } // параметры, специфичные для метода проверки, опционально
    },

    aux: { ... } // обновление вспомогательных данных.
  },

  get: {
    // Метаданные для запроса из топика; список, разделенный пробелами, допустимые строки
    // это "desc", "sub", "data", "tags"; по умолчанию: ничего не запрашивать; неизвестные строки
    // игнорируются; см. {get  what} для подробностей
    what: "desc sub data", // string, опционально

    // Опциональные параметры для {get what="desc"}
    desc: {
      ims: "2015-10-06T18:07:30.038Z" // timestamp, "if modified since" - возвращать
              // значения public и private только если хотя бы одно из них было
              // обновлено после указанной временной метки, опционально
    },

    // Опциональные параметры для {get what="sub"}
    sub: {
      ims: "2015-10-06T18:07:30.038Z", // timestamp, "if modified since" - возвращать
              // только те подписки, которые были изменены после указанной
              // временной метки, опционально
      user: "usr2il9suCbuko", // string, возвращать результаты для одного пользователя,
                            // любой топик, кроме 'me', опционально
      topic: "usr2il9suCbuko", // string, возвращать результаты для одного топика,
                            // только топик 'me', опционально
      limit: 20 // integer, ограничить количество возвращаемых объектов
    },

    // Опциональные параметры для {get what="data"}, см. {get what="data"} для подробностей
    data: {
      since: 123, // integer, загружать сообщения с ID, выданными сервером, больше или равными
            // этому (включительно/закрыто), опционально
      before: 321, // integer, загружать сообщения с последовательными ID, выданными сервером, меньше
            // этого (исключительно/открыто), опционально
      limit: 20, // integer, ограничить количество возвращаемых объектов,
                 // по умолчанию: 32, опционально
    } // object, опционально
  }
}
```

См. [Поля Trusted, Public и Private](#поля-trusted-public-private-auxiliary) для соображений формата `trusted`, `private` и `public`.

#### `{leave}`

Это аналог сообщения `{sub}`. Оно также выполняет две функции:
* выход из топика без отписки (`unsub=false`)
* отписка (`unsub=true`)

Сервер отвечает на `{leave}` пакетом `{ctrl}`. Выход без отписки влияет только на текущую сессию. Выход с отпиской повлияет на все сессии пользователя.

```js
leave: {
  id: "1a2b3",  // string, ID сообщения, предоставленный клиентом, опционально
  topic: "grp1XUtEhjv6HND",   // string, топик для выхода, отписки или
                              // удаления, требуется
  unsub: true // boolean, выйти и отписаться, опционально, по умолчанию: false
}
```

#### `{pub}`

Сообщение используется для распространения содержимого подписчикам топика.

```js
pub: {
  id: "1a2b3", // string, ID сообщения, предоставленный клиентом, опционально
  topic: "grp1XUtEhjv6HND", // string, топик для публикации, требуется
  noecho: false, // boolean, подавить эхо (см. ниже), опционально
  head: { key: "value", ... }, // набор строковых пар ключ-значение, опционально
  content: { ... }  // object, содержимое, определенное приложением, для публикации
               // подписчикам топика, требуется
}
```

Подписчики топика получают `content` в сообщении [`{data}`](#data). По умолчанию исходная сессия получает копию `{data}`, как и любая другая сессия, в настоящее время присоединенная к топику. Если по какой-то причине исходная сессия не хочет получать копию данных, которые она только что опубликовала, установите `noecho` в `true`.

См. [Формат содержимого](#формат-содержимого) для соображений формата `content`.

Следующие значения в настоящее время определены для поля `head`:

* `attachments`: массив путей, указывающих медиа, прикрепленные к этому сообщению `["/v0/file/s/sJOD_tZDPz0.jpg"]`.
* `auto`: `true`, когда сообщение было отправлено автоматически, т.е. чатботом или автоответчиком.
* `forwarded`: индикатор того, что сообщение является пересланным сообщением, уникальный ID исходного сообщения, `"grp1XUtEhjv6HND:123"`.
* `mentions`: массив ID пользователей, упомянутых (`@alice`) в сообщении: `["usr1XUtEhjv6HND", "usr2il9suCbuko"]`.
* `mime`: MIME-тип содержимого сообщения, `"text/x-drafty"`; `null` или отсутствующее значение интерпретируется как `"text/plain"`.
* `replace`: индикатор того, что сообщение является исправлением/заменой другого сообщения, уникальный ID сообщения в топике, которое обновляется/заменяется, `":123"`
* `reply`: индикатор того, что сообщение является ответом на другое сообщение, уникальный ID исходного сообщения, `"grp1XUtEhjv6HND:123"`.
* `sender`: ID пользователя отправителя, добавленный сервером, когда сообщение отправлено от имени другого пользователя, `"usr1XUtEhjv6HND"`.
* `thread`: индикатор того, что сообщение является частью ветки разговора, уникальный ID первого сообщения в ветке в топике, `":123"`; `thread` предназначен для пометки плоского списка сообщений в отличие от создания дерева.
* `webrtc`: строка, представляющая состояние видеозвонка, которое представляет сообщение. Возможные значения:
  * `"started"`: звонок был инициирован и устанавливается
  * `"accepted"`: звонок был принят и установлен
  * `"finished"`: ранее успешно установленный звонок был завершен
  * `"missed"`: звонок истек до установления
  * `"declined"`: звонок был завершен вызываемым абонентом до установления
  * `"busy"`: звонок был отклонен из-за того, что вызываемый абонент находится в другом звонке.
  * `"disconnected"`: звонок был завершен сервером по другим причинам (например, из-за ошибки)
* `webrtc-duration`: число, представляющее продолжительность видеозвонка (в миллисекундах).

Поля, специфичные для приложения, должны начинаться с `x-<application-name>-`. Хотя сервер еще не применяет это правило, он может начать делать это в будущем.

Уникальный ID сообщения должен формироваться как `<topic_name>:<seqId>` везде, где возможно, например `"grp1XUtEhjv6HND:123"`. Если топик опущен, т.е. `":123"`, предполагается, что это текущий топик.

#### `{get}`

Запрос метаданных топика, таких как описание или список подписчиков, или запрос истории сообщений. Запрашивающий должен быть [подписан и присоединен](#sub) к топику, чтобы получить полный ответ. Некоторая ограниченная информация `desc` и `sub` доступна без присоединения.

```js
get: {
  id: "1a2b3", // string, ID сообщения, предоставленный клиентом, опционально
  topic: "grp1XUtEhjv6HND", // string, имя топика для запроса данных
  what: "sub desc data del cred", // string, список параметров для запроса, разделенный пробелами;
                        // неизвестные значения игнорируются; требуется

  // Опциональные параметры для {get what="desc"}
  desc: {
    ims: "2015-10-06T18:07:30.038Z" // timestamp, "if modified since" - возвращать
          // значения public и private только если хотя бы одно из них было
          // обновлено после указанной временной метки, опционально
  },

  // Опциональные параметры для {get what="sub"}
  sub: {
    ims: "2015-10-06T18:07:30.038Z", // timestamp, "if modified since" - возвращать
          // значения public и private только если хотя бы одно из них было
          // обновлено после указанной временной метки, опционально
    user: "usr2il9suCbuko", // string, возвращать результаты для одного пользователя,
                          // любой топик, кроме 'me', опционально
    topic: "usr2il9suCbuko", // string, возвращать результаты для одного топика,
                           // только топик 'me', опционально
    limit: 20 // integer, ограничить количество возвращаемых объектов
  },

  // Опциональные параметры для {get what="data"}
  data: {
    since: 123, // integer, загружать сообщения с ID, выданными сервером, больше или равными
                // этому (включительно/закрыто), опционально
    before: 321, // integer, загружать сообщения с последовательными ID, выданными сервером, меньше
               // этого (исключительно/открыто), опционально
    limit: 20, // integer, ограничить количество возвращаемых объектов, по умолчанию: 32,
               // опционально
  },

  // Опциональные параметры для {get what="del"}
  del: {
    since: 5, // integer, загружать удаленные диапазоны с ID транзакций удаления больше
              // или равными этому (включительно/закрыто), опционально
    before: 12, // integer, загружать удаленные диапазоны с ID транзакций удаления меньше
                // этого (исключительно/открыто), опционально
    limit: 25, // integer, ограничить количество возвращаемых объектов, по умолчанию: 32,
               // опционально
  }
}
```

* `{get what="desc"}`

Запрос описания топика. Сервер отвечает сообщением `{meta}`, содержащим запрошенные данные. См. `{meta}` для подробностей.
Если указан `ims` и данные не были обновлены, сообщение пропустит поля `trusted`, `public` и `private`.

Ограниченная информация доступна без [присоединения](#sub) к топику сначала.

См. [Поля Trusted, Public и Private](#поля-trusted-public-private-auxiliary) для соображений формата `trusted`, `private` и `public`.

* `{get what="sub"}`

Получить список подписчиков. Сервер отвечает сообщением `{meta}`, содержащим список подписчиков. См. `{meta}` для подробностей.
Для топика `me` запрос возвращает список подписок пользователя. Если указан `ims` и данные не были обновлены,
отвечает сообщением `{ctrl}` "not modified".

Только собственная подписка пользователя возвращается без [присоединения](#sub) к топику сначала.

* `{get what="tags"}`

Запрос индексированных тегов. Сервер отвечает сообщением `{meta}`, содержащим массив строковых тегов. См. `{meta}` и топик `fnd` для подробностей.
Поддерживается только для топиков `me` и групповых топиков.

* `{get what="data"}`

Запрос истории сообщений. Сервер отправляет сообщения `{data}`, соответствующие параметрам, предоставленным в поле `data` запроса.
Поле `id` сообщений данных не предоставляется, так как это общее для сообщений данных. Когда все сообщения `{data}` переданы, отправляется сообщение `{ctrl}`.

* `{get what="del"}`

Запрос истории удаления сообщений. Сервер отвечает сообщением `{meta}`, содержащим список диапазонов удаленных сообщений.

* `{get what="cred"}`

Запрос [учетных данных](#проверка-учетных-данных). Сервер отвечает сообщением `{meta}`, содержащим массив учетных данных. Поддерживается только для топика `me`.

* `{get what="aux"}`

Запрос вспомогательных данных топика. Сервер отвечает сообщением `{meta}`, содержащим объект с вспомогательными парами ключ-значение.


#### `{set}`

Обновление метаданных топика, удаление сообщений или топика. Запрашивающий обычно ожидается быть [подписан и присоединен](#sub) к топику. Только `desc.private` и `sub.mode` запрашивающего могут быть обновлены без присоединения сначала.

```js
set: {
  id: "1a2b3", // string, ID сообщения, предоставленный клиентом, опционально
  topic: "grp1XUtEhjv6HND", // string, имя топика для обновления, требуется

  // Опциональная полезная нагрузка для обновления описания топика
  desc: {
    defacs: { // новый режим доступа по умолчанию
      auth: "JRWP",  // разрешения доступа для аутентифицированных пользователей
      anon: "JRW" // разрешения доступа для анонимных пользователей
    },
    trusted: { ... }, // полезная нагрузка, определенная приложением, назначенная системной администрацией
    public: { ... }, // полезная нагрузка, определенная приложением, для описания топика
    private: { ... } // частное содержимое, определенное приложением, для каждого пользователя
  },

  // Опциональная полезная нагрузка для обновления подписки(ок)
  sub: {
    user: "usr2il9suCbuko", // string, пользователь, на которого влияет этот запрос;
                            // по умолчанию (пусто) означает текущего пользователя
    mode: "JRWP" // string, изменение режима доступа, либо предоставленное ('user'
                 // определен), либо запрошенное ('user' не определен)
  }, // object, полезная нагрузка для what == "sub"

  // Опциональное обновление тегов (см. описание топика fnd)
  tags: [ // массив строк
    "email:alice@example.com", "tel:1234567890"
  ],

  cred: { // Опциональное обновление учетных данных.
    meth: "email", // string, метод проверки, например "email", "tel", "recaptcha", и т.д.
    val: "alice@example.com", // string, учетные данные для проверки, такие как email или телефон
    resp: "178307", // string, ответ проверки, опционально
    params: { ... } // параметры, специфичные для метода проверки, опционально
  },

  aux: { ... } // пары ключ-значение, определенные приложением
}
```

#### `{del}`

Удаление сообщений, подписок, топиков, пользователей.

```js
del: {
  id: "1a2b3", // string, ID сообщения, предоставленный клиентом, опционально
  topic: "grp1XUtEhjv6HND", // string, затронутый топик, требуется для "topic", "sub",
               // "msg"
  what: "msg", // string, один из "topic", "sub", "msg", "user", "cred"; что
               // удалять - весь топик, подписку, некоторые или все сообщения,
               // пользователя, учетные данные; опционально, по умолчанию: "msg"
  hard: false, // boolean, запрос на жесткое удаление против пометки как удаленного; в случае
               // what="msg" удаление для всех пользователей против только текущего пользователя;
               // опционально, по умолчанию: false
  delseq: [{low: 123, hi: 125}, {low: 156}], // массив диапазонов ID сообщений
               // для удаления, включительно-исключительно, т.е. [low, hi), опционально
  user: "usr2il9suCbuko" // string, пользователь, который удаляется (what="user") или чья
               // подписка удаляется (what="sub"), опционально
  cred: { // учетные данные для удаления (только топик 'me').
    meth: "email", // string, метод проверки, например "email", "tel", и т.д.
    val: "alice@example.com" // string, удаляемые учетные данные
  }
}
```

`what="msg"`

Пользователь может мягко удалить `hard=false` (по умолчанию) или жестко удалить `hard=true` сообщения. Мягкое удаление сообщений скрывает их от запрашивающего пользователя, но не удаляет их из хранилища. Разрешение `R` требуется для мягкого удаления сообщений. Жесткое удаление сообщений удаляет содержимое сообщения из хранилища (`head`, `content`), оставляя заглушку сообщения. Это влияет на всех пользователей. Разрешение `D` необходимо для жесткого удаления сообщений. Сообщения могут быть удалены массово путем указания одного или нескольких диапазонов ID сообщений в параметре `delseq`. Каждой операции удаления присваивается уникальный `delete ID`. Наибольший `delete ID` сообщается обратно в `clear` сообщения `{meta}`.

`what="sub"`

Удаление подписки удаляет указанного пользователя из подписчиков топика. Это требует разрешения `A`. Пользователь не может удалить собственную подписку. Вместо этого следует использовать `{leave}`. Если подписка мягко удалена (по умолчанию), она помечена как удаленная без фактического удаления записи из хранилища.

`what="topic"`

Удаление топика удаляет топик, включая все подписки и все сообщения. Только владелец может удалить топик.

`what="user"`

Удаление пользователя — это очень тяжелая операция. Используйте с осторожностью.

`what="cred"`

Удалить учетные данные. Проверенные учетные данные и те, для которых не было попыток проверки, жестко удаляются. Учетные данные с неудачными попытками проверки мягко удаляются, что предотвращает их повторное использование тем же пользователем.


#### `{note}`

Эфемерное уведомление, сгенерированное клиентом, для пересылки другим клиентам, в настоящее время присоединенным к топику, таким как уведомления о наборе текста или квитанции о доставке. Сообщение является "fire and forget": не хранится на диске как таковое и не подтверждается сервером. Сообщения, считающиеся недействительными, молча отбрасываются.
`{note.recv}` и `{note.read}` действительно изменяют постоянное состояние на сервере. Значение сохраняется и сообщается обратно в соответствующих полях сообщения `{meta.sub}`.

```js
note: {
  topic: "grp1XUtEhjv6HND", // string, топик для уведомления, требуется
  what: "kp", // string, тип действия уведомления.
  seq: 123,   // integer, ID сообщения, которое подтверждается, требуется для
              // 'recv' & 'read'.
  unread: 10, // integer, общее количество непрочитанных сообщений, сообщенное клиентом, опционально.
  event: "ringing", // string, поддействие; в настоящее время используется только видеозвонками/аудиозвонками,
                    // когда what="call".
  payload: {  // object, требуемая полезная нагрузка для 'call' и 'data'.
    ...
  }
}
```

Следующие типы действий в настоящее время определены:
* call: обновление статуса видеозвонка.
* data: общий пакет структурированных данных, обычно ответ формы.
* kp: нажатие клавиши, т.е. уведомление о наборе текста. Клиент должен использовать его, чтобы указать, что пользователь составляет новое сообщение.
* kpa: аудиосообщение находится в процессе записи.
* kpv: видеосообщение находится в процессе записи.
* read: сообщение `{data}` просмотрено (прочитано) пользователем. Это также подразумевает `recv`.
* recv: сообщение `{data}` получено клиентским программным обеспечением, но может еще не быть просмотрено пользователем.

Уведомления `read` и `recv` могут опционально включать значение `unread`, которое является общим количеством непрочитанных сообщений, определенным этим клиентом. Счетчик `unread` на пользователя поддерживается сервером: он увеличивается, когда новые сообщения `{data}` отправляются пользователю, и сбрасывается на значения, сообщенные сообщением `{note unread=...}`. Значение `unread` никогда не уменьшается сервером. Значение включается в push-уведомления для отображения на значке на iOS:
<p align="center">
  <img src="./ios-pill-128.png" alt="Tinode iOS icon with a pill counter" width=64 height=64 />
</p>


### Сообщения от сервера к клиенту

Сообщения к сессии, сгенерированные в ответ на конкретный запрос, содержат поле `id`, равное id исходного сообщения. `id` не интерпретируется сервером.

Большинство сообщений от сервера к клиенту имеют поле `ts`, которое является временной меткой, когда сообщение было сгенерировано сервером.

#### `{data}`

Содержимое, опубликованное в топике. Эти сообщения — единственные сообщения, сохраняемые в базе данных; сообщения `{data}` транслируются всем подписчикам топика с разрешением `R`.

```js
data: {
  topic: "grp1XUtEhjv6HND", // string, топик, который распространил это сообщение,
                            // всегда присутствует
  from: "usr2il9suCbuko", // string, id пользователя, который опубликовал
                          // сообщение; может отсутствовать, если сообщение было
                          // сгенерировано сервером
  head: { key: "value", ... }, // набор строковых пар ключ-значение, переданных
                               // без изменений из {pub}, опционально
  ts: "2015-10-06T18:07:30.038Z", // string, временная метка
  seq: 123, // integer, последовательный ID, выданный сервером
  content: { ... } // object, содержимое, определенное приложением, точно так же, как опубликовано
              // пользователем в сообщении {pub}
}
```

Сообщения данных имеют поле `seq`, которое содержит последовательный числовой ID, сгенерированный сервером. ID гарантированно уникальны в пределах топика. ID начинаются с 1 и последовательно увеличиваются с каждым успешным сообщением [`{pub}`](#pub), полученным топиком.

См. [Формат содержимого](#формат-содержимого) для соображений формата `content`.

См. сообщение [`{pub}`](#pub) для возможных значений поля `head`.


#### `{ctrl}`

Общий ответ, указывающий на ошибку или условие успеха. Сообщение отправляется исходной сессии.

```js
ctrl: {
  id: "1a2b3", // string, ID сообщения, предоставленный клиентом, опционально
  topic: "grp1XUtEhjv6HND", // string, имя топика, если это ответ в контексте
                            // топика, опционально
  code: 200, // integer, код, указывающий на успех или неудачу запроса, следует
             // модели HTTP кодов состояния, всегда присутствует
  text: "OK", // string, текст с более подробной информацией о результате, всегда присутствует
  params: { ... }, // object, общие параметры ответа, зависящие от контекста,
                   // опционально
  ts: "2015-10-06T18:07:30.038Z", // string, временная метка
}
```

#### `{meta}`

Информация о метаданных топика или подписчиках, отправленная в ответ на сообщение `{get}`, `{set}` или `{sub}` исходной сессии.

```js
meta: {
  id: "1a2b3", // string, ID сообщения, предоставленный клиентом, опционально
  topic: "grp1XUtEhjv6HND", // string, имя топика, если это ответ в
                            // контексте топика, опционально
  ts: "2015-10-06T18:07:30.038Z", // string, временная метка
  desc: {
    created: "2015-10-24T10:26:09.716Z",
    updated: "2015-10-24T10:26:09.716Z",
    status: "ok", // статус аккаунта; включен только для топика `me` и только если
                  // запрос отправлен сессией, аутентифицированной как root.
    defacs: { // разрешения доступа по умолчанию топика; присутствует только если текущий
              // пользователь имеет разрешение 'S'
      auth: "JRWP", // доступ по умолчанию для аутентифицированных пользователей
      anon: "N" // доступ по умолчанию для анонимных пользователей
    },
    acs: {  // фактические разрешения доступа пользователя
      want: "JRWP", // string, запрошенное разрешение доступа
      given: "JRWP", // string, предоставленное разрешение доступа
    mode: "JRWP" // string, комбинация want и given
    },
    seq: 123, // integer, id последнего сообщения {data}, выданный сервером
    read: 112, // integer, ID сообщения, которое пользователь утверждает через сообщение {note}
              // что прочитал, опционально
    recv: 115, // integer, как 'read', но получено, опционально
    clear: 12, // integer, в случае, если некоторые сообщения были удалены, наибольший ID
               // удаленного сообщения, опционально
    trusted: { ... }, // полезная нагрузка, определенная приложением, доступная для записи системной
                      // администрацией, доступная для чтения всем
    public: { ... }, // данные, определенные приложением, доступные для записи владельцем топика,
                     // доступные для чтения всем
    private: { ... } // данные, определенные приложением, которые доступны только текущему
                     // пользователю
  }, // object, описание топика, опционально
  sub:  [ // массив объектов, подписчики топика или подписки пользователя, опционально
    {
      user: "usr2il9suCbuko", // string, ID пользователя, которого описывает эта подписка
                            // отсутствует при запросе 'me'.
      updated: "2015-10-24T10:26:09.716Z", // временная метка последнего изменения в
                                           // подписке, присутствует только для
                                           // собственных подписок запрашивающего
      touched: "2017-11-02T09:13:55.530Z", // временная метка последнего сообщения в
                                           // топике (может также включать другие события
                                           // в будущем, такие как новые подписчики)
      acs: {  // разрешения доступа пользователя
        want: "JRWP", // string, запрошенное разрешение доступа, присутствует для собственных
              // подписок пользователя и когда запрашивающий является менеджером или владельцем топика
        given: "JRWP", // string, предоставленное разрешение доступа, опционально точно так же, как 'want'
        mode: "JRWP" // string, комбинация want и given
      },
      read: 112, // integer, ID сообщения, которое пользователь утверждает через сообщение {note}
                 // что прочитал, опционально.
      recv: 315, // integer, как 'read', но получено, опционально.
      clear: 12, // integer, в случае, если некоторые сообщения были удалены, наибольший ID
                 // удаленного сообщения, опционально.
      trusted: { ... }, // полезная нагрузка, определенная приложением, назначенная системной
                        // администрацией
      public: { ... }, // объект 'public' пользователя, определенный приложением, отсутствует при
                       // запросе P2P топиков.
      private: { ... } // объект 'private' пользователя, определенный приложением.
      online: true, // boolean, текущий онлайн-статус пользователя; если это
                    // групповой или p2p топик, это онлайн-статус пользователя в топике,
                    // т.е. если пользователь присоединен и слушает сообщения; если это
                    // ответ на запрос 'me', это говорит, онлайн ли топик
                    // p2p считается онлайн, если другая сторона
                    // онлайн, не обязательно присоединена к топику; групповой топик
                    // считается онлайн, если у него есть хотя бы один активный
                    // подписчик.

      // Следующие поля присутствуют только при запросе топика 'me'

      topic: "grp1XUtEhjv6HND", // string, топик, который описывает эта подписка
      seq: 321, // integer, id последнего сообщения {data}, выданный сервером

      // Следующее поле присутствует только при запросе топика 'me' и
      // описанный топик является P2P топиком
      seen: { // object, если это P2P топик, информация о том, когда собеседник был последний раз
              // онлайн
        when: "2015-10-24T10:26:09.716Z", // временная метка
        ua: "Tinode/1.0 (Android 5.1)" // string, user agent клиента собеседника
      }
    },
    ...
  ],
  tags: [ // массив тегов, по которым индексируется топик или пользователь (в случае топика "me")
    "email:alice@example.com", "tel:+1234567890", "flowers"
  ],
  cred: [ // массив учетных данных пользователя
    {
      meth: "email", // string, метод проверки
      val: "alice@example.com", // string, значение учетных данных
      done: true     // статус проверки
    },
    ...
  ],
  del: {
    clear: 3, // ID последней применимой транзакции 'delete'
    delseq: [{low: 15}, {low: 22, hi: 28}, ...], // диапазоны ID удаленных сообщений
  },
  aux: { ... } // пары ключ-значение, определенные приложением, доступные для записи менеджерами топика,
               // доступные для чтения подписчиками топика.
}
```

#### `{pres}`

Tinode использует сообщение `{pres}` для информирования клиентов о важных событиях. Отдельный [документ](https://docs.google.com/spreadsheets/d/e/2PACX-1vStUDHb7DPrD8tF5eANLu4YIjRkqta8KOhLvcj2precsjqR40eDHvJnnuuS3bw-NcWsP1QKc7GSTYuX/pubhtml?gid=1959642482&single=true) объясняет все возможные случаи использования.

```js
pres: {
  topic: "me", // string, топик, который получает уведомление, всегда присутствует
  src: "grp1XUtEhjv6HND", // string, топик или пользователь, на которого влияет изменение, всегда присутствует
  what: "on", // string, тип действия, что изменилось, всегда присутствует
  seq: 123, // integer, "what" это "msg", ID сообщения, выданный сервером,
            // опционально
  clear: 15, // integer, "what" это "del", обновление ID транзакции удаления.
  delseq: [{low: 123}, {low: 126, hi: 136}], // массив диапазонов, "what" это "del",
             // диапазоны ID удаленных сообщений, опционально
  ua: "Tinode/1.0 (Android 2.2)", // string, строка User Agent, идентифицирующая клиентское
             // программное обеспечение, если "what" это "on" или "ua", опционально
  act: "usr2il9suCbuko",  // string, пользователь, который выполнил действие, опционально
  tgt: "usrRkDVe0PYDOo",  // string, пользователь, на которого влияет действие, опционально
  acs: {want: "+AS-D", given: "+S"} // object, изменения режима доступа, "what" это "acs",
                          // опционально
}
```

Следующие типы действий в настоящее время определены:

* on: топик или пользователь стал онлайн
* off: топик или пользователь стал офлайн
* ua: user agent изменился, например, пользователь вошел с одним клиентом, затем вошел с другим
* upd: описание топика изменилось
* tags: теги топика изменились
* aux: вспомогательные данные топика изменились
* acs: разрешения доступа изменились
* gone: топик больше недоступен, например, он был удален или вы были отписаны от него
* term: подписка на топик была прекращена, вы можете попробовать подписаться снова
* msg: доступно новое сообщение
* read: одно или несколько сообщений были прочитаны получателем
* recv: одно или несколько сообщений были получены получателем
* del: сообщения были удалены


Сообщения `{pres}` являются чисто транзиентными: они не хранятся, и не предпринимается попытка доставить их позже, если пункт назначения временно недоступен.

Временная метка отсутствует в сообщениях `{pres}`.


#### `{info}`

Пересланное уведомление `{note}`, сгенерированное клиентом. Сервер гарантирует, что сообщение соответствует этой спецификации и что содержимое полей `topic` и `from` корректно. Другое содержимое копируется из сообщения `{note}` дословно и может потенциально быть неверным или вводящим в заблуждение, если отправитель того желает.

```js
info: {
  topic: "grp1XUtEhjv6HND", // string, затронутый топик, всегда присутствует
  src: "usrRkDVe0PYDOo",  // string, топик, где произошло событие;
                          // присутствует только когда "topic": "me"
  from: "usr2il9suCbuko", // string, id пользователя, который опубликовал
                          // сообщение, всегда присутствует
  what: "read", // string, один из "kp", "recv", "read", "data", см. клиентскую {note},
                // всегда присутствует
  seq: 123, // integer, ID сообщения, которое клиент подтвердил,
            // гарантируется 0 < read <= recv <= {ctrl.params.seq}; присутствует для recv &
            // read
  event: "ringing", // string, используется видеозвонками/аудиозвонками
  payload: { ... }  // object, произвольная полезная нагрузка, используется видеозвонками
}
```